#!/usr/bin/env python3

# Copyright (c) Meta Platforms, Inc. and its affiliates.
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import os
from collections import defaultdict
from typing import Dict, List, Optional, Union

# TODO: this is not a lab dependency currently, should probably remove it
import pandas as pd

import habitat.datasets.rearrange.samplers.receptacle as hab_receptacle
import habitat.sims.habitat_simulator.sim_utilities as sutils
import habitat_sim
from habitat_sim.physics import ManagedArticulatedObject, ManagedRigidObject


class MetadataInterface:
    """
    Lightweight interface for managing the object semantic metadata from csv files for HSSD.
    TODO: should be promoted and used throughout codebase
    """

    def __init__(self, metadata_source_dict: Dict[str, str]) -> None:
        # digest the HSSD metadata
        self.metadata_source_dict = metadata_source_dict
        self.metadata = self.load_metadata(self.metadata_source_dict)

        self.receptacles: List[hab_receptacle.Receptacle] = None

        # generate a lexicon from the metadata
        self.hash_to_cat: Dict[str, str] = {}
        self.lexicon: List[str] = []  # all object classes annotated
        for index in range(self.metadata.shape[0]):
            cat = self.metadata.at[index, "type"]
            self.hash_to_cat[self.metadata.at[index, "handle"]] = cat
            self.lexicon.append(cat)
        # deduplicate lexicon
        self.lexicon = list(set(self.lexicon))
        # remove non strings (e.g. nan)
        self.lexicon = [
            entry for entry in self.lexicon if isinstance(entry, str)
        ]

        # semantic naming for ReceptacleObjects (e.g. table_1)
        self.recobj_semname_to_handle: Dict[str, str] = {}
        self.recobj_handle_to_semname: Dict[str, str] = {}

    def load_metadata(self, metadata_dict):
        """
        This method loads the metadata about objects and receptacles.
        This data will typically include tags associated with these objects such as type, color etc.
        TODO: Copied from perception.PerceptionSim, should be promoted and de-duplicated.
        """

        # Make sure that metadata_dict is not None
        if not metadata_dict:
            raise ValueError("Cannot load metadata from None")

        # Fetch relevant paths
        metadata_folder = metadata_dict["metadata_folder"]
        object_metadata_path = os.path.join(
            metadata_folder, metadata_dict["obj_metadata"]
        )
        static_object_metadata_path = os.path.join(
            metadata_folder, metadata_dict["staticobj_metadata"]
        )

        # Make sure that the paths are valid
        if not os.path.exists(object_metadata_path):
            raise Exception(
                f"Object metadata file not found, {object_metadata_path}"
            )
        if not os.path.exists(static_object_metadata_path):
            raise Exception(
                f"Receptacle metadata file not found, {static_object_metadata_path}"
            )

        # Read the metadata files
        df_static_objects = pd.read_csv(static_object_metadata_path)
        df_objects = pd.read_csv(object_metadata_path)

        # Rename some columns
        df1 = df_static_objects.rename(
            columns={"id": "handle", "main_category": "type"}
        )
        df2 = df_objects.rename(
            columns={"id": "handle", "clean_category": "type"}
        )

        # Drop the rest of the columns in both DataFrames
        df1 = df1[["handle", "type"]]
        df2 = df2[["handle", "type"]]

        # Merge the two data frames
        union_df = pd.concat([df1, df2], ignore_index=True)

        return union_df

    def refresh_scene_caches(self, sim: habitat_sim.Simulator) -> None:
        """
        When a new Simulator instance is initialized we need to refresh internal instance caches.
        Also populates a mapping of ReceptacleObject semantic names used to specify generation.
        Semantic names are generated by collecting all Receptacle parent objects of each time and enumerating them.
        """

        self.receptacles = hab_receptacle.find_receptacles(sim)

        # TODO: Should this be moved into the Perception module?
        self.recobj_semname_to_handle = {}
        self.recobj_handle_to_semname = {}

        sem_class_counter: Dict[str, int] = defaultdict(lambda: 0)

        for receptacle in self.receptacles:
            receptacle_object = sutils.get_obj_from_handle(
                sim, receptacle.parent_object_handle
            )
            sem_class = self.get_object_instance_category(receptacle_object)
            if sem_class is None:
                print(
                    f"Found Receptacle with unkown parent object '{receptacle.parent_object_handle}' type. Culling this object from available receptacles."
                )
                continue
            # computes the semantic name of the receptacle
            instance_sem_name = f"{sem_class}_{sem_class_counter[sem_class]}"
            sem_class_counter[sem_class] += 1
            self.recobj_semname_to_handle[
                instance_sem_name
            ] = receptacle_object.handle
            self.recobj_handle_to_semname[
                receptacle_object.handle
            ] = instance_sem_name

    def get_object_category(self, obj_hash: str) -> Optional[str]:
        """
        Get the semantic class lexicon entry corresponding to the object hash.
        Returns None if the object does not have a class or cannot be found.
        """

        if obj_hash in self.hash_to_cat:
            obj_class = self.hash_to_cat[obj_hash]
            if isinstance(obj_class, str) and len(obj_class) > 0:
                return obj_class
        return None

    def get_object_instance_category(
        self, obj: Union[ManagedRigidObject, ManagedArticulatedObject]
    ) -> Optional[str]:
        """
        Get the semantic class lexicon entry corresponding to the object isntance's template hash.
        Returns None if the object does not have a class or cannot be found.
        """

        obj_hash = sutils.object_shortname_from_handle(obj.handle)
        obj_cat = self.get_object_category(obj_hash)
        return obj_cat

    def get_scene_lexicon(self, sim: habitat_sim.Simulator):
        """
        Get the lexicon of the current scene contents by scraping the contents.
        """

        scene_lexicon = []
        rom = sim.get_rigid_object_manager()
        aom = sim.get_articulated_object_manager()
        # get all rigid and articulated object instances
        all_objs = list(rom.get_objects_by_handle_substring().values()) + list(
            aom.get_objects_by_handle_substring().values()
        )
        for obj in all_objs:
            obj_hash = sutils.object_shortname_from_handle(obj.handle)
            obj_cat = self.get_object_category(obj_hash)
            scene_lexicon.append(obj_cat)
        # de-dup
        scene_lexicon = list(set(scene_lexicon))
        # remove non-strings (e.g. None)
        scene_lexicon = [
            entry for entry in scene_lexicon if isinstance(entry, str)
        ]
        return scene_lexicon

    def get_scene_objs_of_class(
        self, sim: habitat_sim.Simulator, sem_class: str
    ) -> List[Union[ManagedRigidObject, ManagedArticulatedObject]]:
        """
        Get all objects of a given class in the currently instanced scene.
        """

        objs_of_class: List[
            Union[ManagedRigidObject, ManagedArticulatedObject]
        ] = []
        if sem_class not in self.lexicon:
            print(
                f"get_scene_objs_of_class failed, sem_class '{sem_class}' not in lexicon."
            )
            return objs_of_class

        rom = sim.get_rigid_object_manager()
        aom = sim.get_articulated_object_manager()
        # get all rigid and articulated object instances
        all_objs = list(rom.get_objects_by_handle_substring().values()) + list(
            aom.get_objects_by_handle_substring().values()
        )
        for obj in all_objs:
            obj_hash = sutils.object_shortname_from_handle(obj.handle)
            obj_cat = self.get_object_category(obj_hash)
            if obj_cat == sem_class:
                objs_of_class.append(obj)

        return objs_of_class

    def get_scene_recs_of_class(
        self,
        sem_class: str,
    ):
        """
        Get all Receptacles of a given class in the currently instanced scene.
        :param receptacles: Provide a pre-computed list of Receptacles to search. If not provided, receptacles will be pre-acquired from the Simulator.
        """

        assert (
            self.receptacles is not None
        ), "No receptacles have been scraped from the scene, call  refresh_scene_caches() first."

        class_recs: List[hab_receptacle.Receptacle] = []

        for rec in self.receptacles:
            parent_obj_hash = sutils.object_shortname_from_handle(
                rec.parent_object_handle
            )
            rec_cat = self.get_object_category(parent_obj_hash)
            if rec_cat == sem_class:
                class_recs.append(rec)

        return class_recs

    def get_template_handles_of_class(
        self, mm: habitat_sim.metadata.MetadataMediator, sem_class: str
    ) -> List[str]:
        """
        Search the MetadataMediator for all objects of a given class and return a list of template handles.
        """

        otm = mm.object_template_manager
        class_handles: List[str] = []
        if sem_class not in self.lexicon:
            print(f"'{sem_class}' not in lexicon.")
            return class_handles
        for handle in otm.get_file_template_handles():
            obj_cat = self.get_object_category(
                sutils.object_shortname_from_handle(handle)
            )
            if obj_cat == sem_class:
                class_handles.append(handle)
        return class_handles
